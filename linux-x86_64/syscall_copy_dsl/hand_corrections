We assume that the arguments of syscall_arg are 64-bit aligned.

modifications from the default behaviour of the generator
=========================================================

SYS_getgroups: need to adjust number of bytes copied.
SYS_setgroups: need to adjust number of bytes copied.
SYS_reboot is a fairly complicated one.
SYS_kexec_load: need to adjust number of bytes copied.
SYS_statfs64: no manpage, semantics of param sz unknown.
SYS_fstatfs64: no manpage, semantics of param sz unknown.
SYS_setxattr: copy_buf(syscall_arg[3], sizeof(void))
                -> copy_buf(syscall_arg[3], syscall_arg[4])
SYS_lsetxattr: copy_buf(syscall_arg[3], sizeof(void))
                -> copy_buf(syscall_arg[3], syscall_arg[4])
SYS_fsetxattr: copy_buf(syscall_arg[3], sizeof(void))
                -> copy_buf(syscall_arg[3], syscall_arg[4])
SYS_getxattr: copy_buf(syscall_arg[3], sizeof(void))
                -> copy_buf(syscall_arg[3], syscall_arg[4])
SYS_lgetxattr: copy_buf(syscall_arg[3], sizeof(void))
                -> copy_buf(syscall_arg[3], syscall_arg[4])
SYS_fgetxattr: copy_buf(syscall_arg[3], sizeof(void))
                -> copy_buf(syscall_arg[3], syscall_arg[4])
SYS_listxattr: unsafe_copy_zts(syscall_arg[2])
                -> copy_buf(syscall_arg[2], syscall_arg[3])
SYS_llistxattr: unsafe_copy_zts(syscall_arg[2])
                -> copy_buf(syscall_arg[2], syscall_arg[3])
SYS_flistxattr: unsafe_copy_zts(syscall_arg[2])
                -> copy_buf(syscall_arg[2], syscall_arg[3])
SYS_mincore: weird weird weird
  From man 2 mincore:
  "The  vec  argument must point to an array containing at least
    (length+PAGE_SIZE-1) / PAGE_SIZE bytes. On return, the least
    significant bit of each byte will be set if the corresponding
    page is currently resident in memory, and be clear otherwise."
SYS_pipe: copy_buf(syscall_arg[1], sizeof(int))
           -> copy_buf(syscall_arg[1], 2 * sizeof(int))
SYS_pipe2: copy_buf(syscall_arg[1], sizeof(int))
           -> copy_buf(syscall_arg[1], 2 * sizeof(int))
SYS_io_setup: complicated.
SYS_io_getevents: complicated.
SYS_sendfile:
    switch (syscall_arg[3]) {
      case 0: break;
      default: copy_buf(syscall_arg[3], sizeof(syscall_arg[4])); // offset
               break;
    }
SYS_sendfile64: no manpage
SYS_readlink: unsafe_copy_zts(syscall_arg[2])
               -> copy_buf(syscall_arg[2], syscall_arg[3])
SYS_getgroups16: no manpage
SYS_setgroups16: no manpage
SYS_readv: complicated
SYS_write: unsafe_copy_zts(syscall_arg[2])
            -> copy_buf(syscall_arg[2], syscall_arg[3])
SYS_writev: complicated
  copy_buf(syscall_arg[2], sizeof(struct iovec))
  -> copy_buf(syscall_arg[2], syscall_arg[3] * sizeof(struct iovec));
SYS_pread64: no manpage
SYS_pwrite64: no manpage
SYS_preadv: copy_buf(syscall_arg[2], sizeof(struct iovec))
            -> copy_buf(syscall_arg[2], syscall_arg[3] * sizeof(struct iovec))
SYS_pwritev: copy_buf(syscall_arg[2], sizeof(struct iovec))
            -> copy_buf(syscall_arg[2], syscall_arg[3] * sizeof(struct iovec))
case SYS_getcwd: unsafe_copy_zts(syscall_arg[1])
                -> copy_buf(syscall_arg[1], syscall_arg[2])
SYS_lookup_dcookie: unsafe_copy_zts(syscall_arg[2])
                    -> copy_buf(syscall_arg[2], syscall_arg[3])
SYS_quotactl: weird weird weird
SYS_getdents: copy_buf(syscall_arg[2], sizeof(struct linux_dirent))
              -> copy_buf(syscall_arg[2], syscall_arg[2])
SYS_getdents64: no manpage
SYS_setsockopt: unsafe_copy_zts(syscall_arg[4])
                -> copy_buf(syscall_arg[4], syscall_arg[5])
SYS_getsockopt: unsafe_copy_zts(syscall_arg[4])
                -> copy_buf(syscall_arg[4], ((int *) syscall_arg[5])[1])
SYS_bind: copy_buf(syscall_arg[2], sizeof(struct sockaddr))
          -> copy_buf(syscall_arg[2], syscall_arg[3])
SYS_connect: copy_buf(syscall_arg[2], sizeof(struct sockaddr))
          -> copy_buf(syscall_arg[2], syscall_arg[3])
SYS_accept:
    switch(syscall_arg[2]) {
            case 0: break;
            default: copy_buf(syscall_arg[2], syscall_arg[3][1])
                     copy_buf(syscall_arg[3], sizeof(int))
                     break;
    }
SYS_accept4:
    switch(syscall_arg[2]) {
            case 0: break;
            default: copy_buf(syscall_arg[2], syscall_arg[3][1])
                     copy_buf(syscall_arg[3], sizeof(int))
                     break;
    }
SYS_getsockname: copy_buf(syscall_arg[2], sizeof(struct sockaddr))
                -> copy_buf(syscall_arg[2], syscall_arg[3][1])
SYS_getpeername: copy_buf(syscall_arg[2], sizeof(struct sockaddr))
                -> copy_buf(syscall_arg[2], syscall_arg[3][1])
SYS_sendmmsg: copy_buf(syscall_arg[2], sizeof(struct mmsghdr))
                -> copy_buf(syscall_arg[2], syscall_arg[3] * sizeof(struct mmsghdr))
SYS_recvmmsg:  copy_buf(syscall_arg[2], sizeof(struct mmsghdr))
                -> copy_buf(syscall_arg[2], syscall_arg[3] * sizeof(struct mmsghdr))
SYS_socketpair: copy_buf(syscall_arg[4], sizeof(int))
                 -> copy_buf(syscall_arg[4], 2 * sizeof(int))
SYS_socketcall: ??? unclear what the size of arg4 is.
SYS_poll: copy_buf(syscall_arg[1], sizeof(struct pollfd))
        -> copy_buf(syscall_arg[1], syscall_arg[2] * sizeof(struct pollfd))
SYS_old_select: no man
SYS_epoll_wait:
    switch (syscall_arg[3]) {
            case 0: break;
            default: copy_buf(syscall_arg[2], syscall_arg[3] * sizeof(struct epoll_event));
                     rec_copy_struct(events);
                     break;
    }
SYS_epoll_pwait:
    switch (syscall_arg[3]) {
            case 0: break;
            default: copy_buf(syscall_arg[2], syscall_arg[3] * sizeof(struct epoll_event));
                     rec_copy_struct(events);
                     copy_buf(syscall_arg[5], sizeof(sigset_t));
                     break;
    }
SYS_gethostname: unsafe_copy_zts(syscall_arg[1])
                 -> copy_buf(syscall_arg[1], syscall_arg[3]);
SYS_sethostname: unsafe_copy_zts(syscall_arg[1])
                 -> copy_buf(syscall_arg[1], syscall_arg[3]);
SYS_setdomainname: unsafe_copy_zts(syscall_arg[1])
                 -> copy_buf(syscall_arg[1], syscall_arg[3]);
SYS_newuname: see thing with man, unclear.
SYS_uname: see thing with man, unclear.
SYS_olduname: see thing with man, unclear.
SYS_prlimit64: no man.
SYS_msgsnd: copy_buf(syscall_arg[2], sizeof(struct msgbuf))
        -> copy_buf(syscall_arg[2], sizeof(long) + syscall_arg[3])
        XXX: this might be slightly wrong, because of struct alignment.
        See man.
SYS_msgrcv: copy_buf(syscall_arg[2], sizeof(struct msgbuf))
        -> copy_buf(syscall_arg[2], sizeof(long) + syscall_arg[3])
        XXX: this might be slightly wrong, because of struct alignment.
        See man.
SYS_semop: copy_buf(syscall_arg[2], sizeof(struct sembuf))
            -> copy_buf(syscall_arg[2], syscall_arg[3] * sizeof(struct sembuf))
            sembuf not detailed.
SYS_semtimedop: copy_buf(syscall_arg[2], sizeof(struct sembuf))
            -> copy_buf(syscall_arg[2], syscall_arg[3] * sizeof(struct sembuf))
            sembuf not detailed.
SYS_shmat: treat syscall_arg[2] as a normal argument.
SYS_shmdt: treat syscall_arg[2] as a normal argument.
SYS_shmctl: shmid_ds not clearly defined.
SYS_ipc: man doesn’t help.
SYS_mq_open: no info on mq_attr
SYS_mq_timedsend: unsafe_copy_zts(syscall_arg[2])
                  -> copy_buf(syscall_arg[2], syscall_arg[3])
SYS_mq_timedceceive: unsafe_copy_zts(syscall_arg[2])
                  -> copy_buf(syscall_arg[2], syscall_arg[3])

types used by syscalls (uncomplete)
===================================

__s32
__sighandler_t
__u32
aio_context_t
cap_user_data_t
cap_user_header_t
char
clock_t
clockid_t
dev
fd_set
flags
gid_t
int
key_serial_t
key_t
loff_t
long
mode_t
mqd_t
nr_reqs
nsops
off_t
old_gid_t
old_sigset_t
old_uid_t
pid_t
qid_t
sa_family_t
siginfo_t
sigset_t
size_t
socklen_t
struct __old_kernel_stat // XXX Not in the manpages
struct __sysctl_args {
  int    *name;    /* integer vector describing variable */
  int     nlen;    /* length of this vector */
  void   *oldval;  /* 0 or address where to store old value */
  size_t *oldlenp; /* available room for old value,
                      overwritten by actual size of old value */
  void   *newval;  /* 0 or address of new value */
  size_t  newlen;  /* size of new value */
};
typedef union epoll_data {
  void        *ptr;
  int          fd;
  uint32_t     u32;
  uint64_t     u64;
} epoll_data_t;
struct epoll_event {
  uint32_t     events;      /* Epoll events */
  epoll_data_t data;        /* User data variable */
};
struct file_handle // XXX no man
struct getcpu_cache // XXX no man
struct io_event // XXX not in manpage
struct iocb // XXX not in manpage
struct iovec {
  void  *iov_base;    /* Starting address */
  size_t iov_len;     /* Number of bytes to transfer */
};
struct ipc_perm {
  key_t          __key;       /* Key supplied to msgget(2) */
  uid_t          uid;         /* Effective UID of owner */
  gid_t          gid;         /* Effective GID of owner */
  uid_t          cuid;        /* Effective UID of creator */
  gid_t          cgid;        /* Effective GID of creator */
  unsigned short mode;        /* Permissions */
  unsigned short __seq;       /* Sequence number */
};
struct itimerspec {
  struct timespec it_interval;  /* Timer interval */
  struct timespec it_value;     /* Initial expiration */
};
struct itimerval {
  struct timeval it_interval; /* next value */
  struct timeval it_value;    /* current value */
};
struct kexec_segment {
  void   *buf;        /* Buffer in user space */
  size_t  bufsz;      /* Buffer length in user space */
  void   *mem;        /* Physical address of kernel */
  size_t  memsz;      /* Physical address length */
};
struct linux_dirent {
  unsigned long  d_ino;     /* Inode number */
  unsigned long  d_off;     /* Offset to next linux_dirent */
  unsigned short d_reclen;  /* Length of this linux_dirent */
  char           d_name[];  /* Filename (null-terminated) */
  /* length is actually (d_reclen - 2 -
     offsetof(struct linux_dirent, d_name) */
  /*
     char           pad;       // Zero padding byte
     char           d_type;    // File type (only since Linux 2.6.4;
  // offset is (d_reclen - 1))
   */

}
struct linux_dirent64 // XXX not in manpages
struct mmap_arg_struct // XXX no man
struct mmsghdr {
  struct msghdr msg_hdr;  /* Message header */
  unsigned int  msg_len;  /* Number of bytes transmitted */
};
struct mq_attr // XXX no man
struct msgbuf {
  long mtype;       /* message type, must be > 0 */
  char mtext[1];    /* message data */
};
struct msghdr {
  void         *msg_name;       /* optional address */
  socklen_t     msg_namelen;    /* size of address */
  struct iovec *msg_iov;        /* scatter/gather array */
  size_t        msg_iovlen;     /* # elements in msg_iov */
  void         *msg_control;    /* ancillary data, see below */
  size_t        msg_controllen; /* ancillary data buffer len */
  int           msg_flags;      /* flags on received message */
};
struct msqid_ds { // XXX types
  struct ipc_perm msg_perm;     /* Ownership and permissions */
  time_t          msg_stime;    /* Time of last msgsnd(2) */
  time_t          msg_rtime;    /* Time of last msgrcv(2) */
  time_t          msg_ctime;    /* Time of last change */
  unsigned long   __msg_cbytes; /* Current number of bytes in
                                   queue (nonstandard) */
  msgqnum_t       msg_qnum;     /* Current number of messages
                                   in queue */
  msglen_t        msg_qbytes;   /* Maximum number of bytes
                                   allowed in queue */
  pid_t           msg_lspid;    /* PID of last msgsnd(2) */
  pid_t           msg_lrpid;    /* PID of last msgrcv(2) */
};
struct new_utsname // XXX no man, although struct utsname is defined in uname(2)
struct old_linux_dirent // XXX no man
struct old_utsname // XXX no man
struct oldold_utsname // XXX no man
struct perf_event_attr // XXX no man
struct pollfd {
  int   fd;         /* file descriptor */
  short events;     /* requested events */
  short revents;    /* returned events */
};
struct rlimit {
  rlim_t rlim_cur;  /* Soft limit */
  rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
};
struct rlimit64 // XXX no man
struct robust_list_head // XXX no man
struct rusage {
  struct timeval ru_utime; /* user CPU time used */
  struct timeval ru_stime; /* system CPU time used */
  long   ru_maxrss;        /* maximum resident set size */
  long   ru_ixrss;         /* integral shared memory size */
  long   ru_idrss;         /* integral unshared data size */
  long   ru_isrss;         /* integral unshared stack size */
  long   ru_minflt;        /* page reclaims (soft page faults) */
  long   ru_majflt;        /* page faults (hard page faults) */
  long   ru_nswap;         /* swaps */
  long   ru_inblock;       /* block input operations */
  long   ru_oublock;       /* block output operations */
  long   ru_msgsnd;        /* IPC messages sent */
  long   ru_msgrcv;        /* IPC messages received */
  long   ru_nsignals;      /* signals received */
  long   ru_nvcsw;         /* voluntary context switches */
  long   ru_nivcsw;        /* involuntary context switches */
};
struct sched_param // XXX this one is bad... #include <sched.h> apparently.
struct sel_arg_struct // XXX no man
struct sembuf // XXX no man
struct shmid_ds // XXX defined in <sys/shm.h>
struct sigevent {
  int          sigev_notify; /* Notification method */
  int          sigev_signo;  /* Notification signal */
  union sigval sigev_value;  /* Data passed with
                                notification */
  void       (*sigev_notify_function) (union sigval);
  /* Function used for thread
     notification (SIGEV_THREAD) */
  void        *sigev_notify_attributes;
  /* Attributes for notification thread
     (SIGEV_THREAD) */
  pid_t        sigev_notify_thread_id;
  /* ID of thread to signal (SIGEV_THREAD_ID) */
};
struct siginfo // XXX this one is bad as well... #include <sys/types.h> #include <sys/wait.h>
struct sockaddr {
  sa_family_t sa_family;
  char        sa_data[14];
}
struct stat { // XXX most of these types probably aren’t here yet.
  dev_t     st_dev;     /* ID of device containing file */
  ino_t     st_ino;     /* inode number */
  mode_t    st_mode;    /* protection */
  nlink_t   st_nlink;   /* number of hard links */
  uid_t     st_uid;     /* user ID of owner */
  gid_t     st_gid;     /* group ID of owner */
  dev_t     st_rdev;    /* device ID (if special file) */
  off_t     st_size;    /* total size, in bytes */
  blksize_t st_blksize; /* blocksize for file system I/O */
  blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
  time_t    st_atime;   /* time of last access */
  time_t    st_mtime;   /* time of last modification */
  time_t    st_ctime;   /* time of last status change */
};
struct stat64 // XXX no man
struct statfs { // XXX these types are likely not here.
  __SWORD_TYPE f_type;    /* type of file system (see below) */
  __SWORD_TYPE f_bsize;   /* optimal transfer block size */
  fsblkcnt_t   f_blocks;  /* total data blocks in file system */
  fsblkcnt_t   f_bfree;   /* free blocks in fs */
  fsblkcnt_t   f_bavail;  /* free blocks available to
                             unprivileged user */
  fsfilcnt_t   f_files;   /* total file nodes in file system */
  fsfilcnt_t   f_ffree;   /* free file nodes in fs */
  fsid_t       f_fsid;    /* file system id */
  __SWORD_TYPE f_namelen; /* maximum length of filenames */
  __SWORD_TYPE f_frsize;  /* fragment size (since Linux 2.6) */
  __SWORD_TYPE f_spare[5];
};
struct statfs64 // XXX not in manpages
struct sysinfo {
  long uptime;             /* Seconds since boot */
  unsigned long loads[3];  /* 1, 5, and 15 minute load averages */
  unsigned long totalram;  /* Total usable main memory size */
  unsigned long freeram;   /* Available memory size */
  unsigned long sharedram; /* Amount of shared memory */
  unsigned long bufferram; /* Memory used by buffers */
  unsigned long totalswap; /* Total swap space size */
  unsigned long freeswap;  /* swap space still available */
  unsigned short procs;    /* Number of current processes */
  unsigned long totalhigh; /* Total high memory size */
  unsigned long freehigh;  /* Available high memory size */
  unsigned int mem_unit;   /* Memory unit size in bytes */
  char _f[20-2*sizeof(long)-sizeof(int)]; /* Padding to 64 bytes */
};
struct timespec {
  time_t tv_sec;        /* seconds */
  long   tv_nsec;       /* nanoseconds */
};
struct timeval {
  time_t      tv_sec;     /* seconds */
  suseconds_t tv_usec;    /* microseconds */
};
struct timex {
  int modes;           /* mode selector */
  long offset;         /* time offset (usec) */
  long freq;           /* frequency offset (scaled ppm) */
  long maxerror;       /* maximum error (usec) */
  long esterror;       /* estimated error (usec) */
  int status;          /* clock command/status */
  long constant;       /* pll time constant */
  long precision;      /* clock precision (usec) (read-only) */
  long tolerance;      /* clock frequency tolerance (ppm)
                         (read-only) */
  struct timeval time; /* current time (read-only) */
  long tick;           /* usecs between clock ticks */
};
struct timezone {
    int tz_minuteswest;     /* minutes west of Greenwich */
    int tz_dsttime;         /* type of DST correction */
  };
struct tms {
  clock_t tms_utime;  /* user time */
  clock_t tms_stime;  /* system time */
  clock_t tms_cutime; /* user time of children */
  clock_t tms_cstime; /* system time of children */
};
struct ustat // XXX no man
struct utimbuf {
  time_t actime;       /* access time */
  time_t modtime;      /* modification time */
}
rlim_t
time_t
timer_t
u32
u64
uid_t
union sigval {          /* Data passed with notification */
  int     sival_int;         /* Integer value */ XXX
  void   *sival_ptr;         /* Pointer value */ XXX
};
void
